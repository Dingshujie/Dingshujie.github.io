<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>3063-dynamic-resource-allocation-kep</title>
    <url>/2022/07/06/3063-dynamic-resource-allocation-kep/</url>
    <content><![CDATA[<h3 id="当前device-plugin方式的局限："><a href="#当前device-plugin方式的局限：" class="headerlink" title="当前device plugin方式的局限："></a>当前device plugin方式的局限：</h3><ol>
<li>设备初始化：当前device plugin没有想过配置可以指定设置初始化的一些配置，例如FPGA设备可能需要在program启动之前 reconfigured or reprogrammed，当前device plugin是不能指定设备的一些属性的。</li>
<li>设备cleanup：当前device plugin未提供通用机制在workload介绍时能清理device上的一些数据，或者对设备进行下电操作等。</li>
<li>部分分配：当前device plugin只支持整数分配，不支持部分分配。举个栗子：新型的GPU有MIG模式，支持把GPU划分为一系列mini-GPU（就是MIG devices）,可以给每个MIG GPU指定不同的memory和计算资源，可以根据应用动态划分MIG device。当前的device plugin机制的话，无法做到动态划分，必须是提前划分好以后，通过device plugin上报给kubelet，kubelet根据提前划分好的MIG device分配给应用。</li>
<li>optional allocation: 有时对于device的需求是soft，如果device 存在并可分配，则分配，类似gpu或者一些crypto-offload engines，如果他们不可用的话，workloads可以使用CPU做替代。</li>
<li>fabric devices: 当前device plugin API是给node-local资源设置的，对于一些 network-attached resource来说并没有单个节点的资源限制。</li>
</ol>
<h3 id="当前方案流程"><a href="#当前方案流程" class="headerlink" title="当前方案流程"></a>当前方案流程</h3><h4 id="是用persistent-resourceclaim流程"><a href="#是用persistent-resourceclaim流程" class="headerlink" title="是用persistent resourceclaim流程"></a>是用persistent resourceclaim流程</h4><p><img src="/2022/07/06/3063-dynamic-resource-allocation-kep/persistent.jpg"></p>
<p>使用inline resouceclaim流程</p>
<p><img src="/2022/07/06/3063-dynamic-resource-allocation-kep/inline.jpg"></p>
<p>涉及整个调度过程过于复杂。</p>
]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>golang sync.Mutex源码分析</title>
    <url>/2022/07/12/golang-sync-Mutex/</url>
    <content><![CDATA[<p>基于golang 版本 1.17</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A Mutex is a mutual exclusion lock.</span></span><br><span class="line"><span class="comment">// The zero value for a Mutex is an unlocked mutex.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A Mutex must not be copied after first use.</span></span><br><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">	state <span class="type">int32</span></span><br><span class="line">	sema  <span class="type">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过Mutex结构体定义可知消耗8个字节</p>
<p>其中state表示状态，如下图所示，</p>
<p><img src="/2022/07/12/golang-sync-Mutex/syncmux.jpg"></p>
<ul>
<li>state的第0位表示的mutexLocked，表示mutex是否被加锁，加锁时置1</li>
<li>state的第1位表示的mutexWoken，表示mutex是否被唤醒，唤醒时置1</li>
<li>state的第2位表示的mutexStarving，表示mutex是否处于饥饿模式，饥饿时置1</li>
<li>state其他位是标识等待这个mutex的goroutines的数量。</li>
</ul>
<p>sema是用于控制锁状态的信号量，其实会映射到semtable中的某个semaroot，持有一棵 地址各不相同的 sudog(s.elem) 的平衡树，所有的等锁的goroutines都会加到这个双向链表中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Mutex fairness.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Mutex can be in 2 modes of operations: normal and starvation.</span></span><br><span class="line"><span class="comment">// In normal mode waiters are queued in FIFO order, but a woken up waiter</span></span><br><span class="line"><span class="comment">// does not own the mutex and competes with new arriving goroutines over</span></span><br><span class="line"><span class="comment">// the ownership. New arriving goroutines have an advantage -- they are</span></span><br><span class="line"><span class="comment">// already running on CPU and there can be lots of them, so a woken up</span></span><br><span class="line"><span class="comment">// waiter has good chances of losing. In such case it is queued at front</span></span><br><span class="line"><span class="comment">// of the wait queue. If a waiter fails to acquire the mutex for more than 1ms,</span></span><br><span class="line"><span class="comment">// it switches mutex to the starvation mode.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// In starvation mode ownership of the mutex is directly handed off from</span></span><br><span class="line"><span class="comment">// the unlocking goroutine to the waiter at the front of the queue.</span></span><br><span class="line"><span class="comment">// New arriving goroutines don&#x27;t try to acquire the mutex even if it appears</span></span><br><span class="line"><span class="comment">// to be unlocked, and don&#x27;t try to spin. Instead they queue themselves at</span></span><br><span class="line"><span class="comment">// the tail of the wait queue.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If a waiter receives ownership of the mutex and sees that either</span></span><br><span class="line"><span class="comment">// (1) it is the last waiter in the queue, or (2) it waited for less than 1 ms,</span></span><br><span class="line"><span class="comment">// it switches mutex back to normal operation mode.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Normal mode has considerably better performance as a goroutine can acquire</span></span><br><span class="line"><span class="comment">// a mutex several times in a row even if there are blocked waiters.</span></span><br><span class="line"><span class="comment">// Starvation mode is important to prevent pathological cases of tail latency.</span></span><br></pre></td></tr></table></figure>

<p>上面是作者在代码中的注释，阐述了Mutex的Fairness。Mutex提供2个模式，一个是正常模式，一个是饥饿模式。</p>
<ul>
<li>正常模式：wait goroutines是以FIFO来排队。当一个goroutines被唤醒的时候，他可能还没获取锁，而此时有一个新的goroutines，因为他已经占用了CPU，有大的概率会获取到锁。在这种模式下会把这个goroutines加到队首，防止长期获取不到锁。如果一个goroutines超过1ms未获取到锁，则切换到饥饿模式。</li>
<li>在饥饿模式下，在调用Unlock的时候会直接将锁交给队首的goroutines.新的goroutines在调用unlock的时候出现，就不要进去自旋模式了，这是是获取不到锁的，所以讲自己加入到队尾。</li>
</ul>
<p>当goroutines获取到锁，查看自己是否是队列中最后一个元素，或者他等待的时间少于1ms，则切换到正常模式。</p>
<p>对于goroutines获取锁来说，正常模式的性能会更好，当时饥饿模式是为了解决一些长尾问题。</p>
<p>在goroutine能否自旋等锁，当前判断条件：</p>
<ul>
<li><p>在普通模式下才能进去自旋</p>
</li>
<li><p>只有在多核机器上运行并且GOMAXPROCS&gt;1</p>
</li>
<li><p>当前机器上至少存在一个正在运行的处理器 P 并且本地运行队列为空；</p>
</li>
<li><p>当前 Goroutine 为了获取该锁进入自旋的次数小于四次；</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Active spinning for sync.Mutex.</span></span><br><span class="line"><span class="comment">//go:linkname sync_runtime_canSpin sync.runtime_canSpin</span></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sync_runtime_canSpin</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="comment">// sync.Mutex is cooperative, so we are conservative with spinning.</span></span><br><span class="line">	<span class="comment">// Spin only few times and only if running on a multicore machine and</span></span><br><span class="line">	<span class="comment">// GOMAXPROCS&gt;1 and there is at least one other running P and local runq is empty.</span></span><br><span class="line">	<span class="comment">// As opposed to runtime mutex we don&#x27;t do passive spinning here,</span></span><br><span class="line">	<span class="comment">// because there can be work on global runq or on other Ps.</span></span><br><span class="line">	<span class="keyword">if</span> i &gt;= active_spin || ncpu &lt;= <span class="number">1</span> || gomaxprocs &lt;= <span class="type">int32</span>(sched.npidle+sched.nmspinning)+<span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> p := getg().m.p.ptr(); !runqempty(p) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自旋操作是优化了解决阻塞-&gt;唤醒-&gt;抢占锁过程，这个前提是持有锁的任务都是短时任务，这里进行自旋的话，期望在短时内获取到锁，减少上下文切换。</p>
<p>这里的自旋是做30次的PAUSE指令，只消耗CPU</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TEXT runtime·procyield(SB),NOSPLIT,$0-0</span><br><span class="line">	MOVL	cycles+0(FP), AX</span><br><span class="line">again:</span><br><span class="line">	PAUSE</span><br><span class="line">	SUBL	$1, AX</span><br><span class="line">	JNZ	again</span><br><span class="line">	RET</span><br></pre></td></tr></table></figure>

<h3 id="正常模式"><a href="#正常模式" class="headerlink" title="正常模式"></a>正常模式</h3><p>首先我们通过下图来看下正常模式的流程。</p>
<p>当前G0当前持有锁，当前有3个goroutines在等待锁，分别是g3,g4,g5都等待队列中，按照FIFO原则。</p>
<p>如果此时G1新进来去获取锁，G1在正常模式下会自旋等锁，如果超过了自旋的次数或者不满足自旋要求时，会将g1加到等待队列的尾部，等待Unlock唤醒。</p>
<p><img src="/2022/07/12/golang-sync-Mutex/normal-lock.jpg"></p>
<p><img src="/2022/07/12/golang-sync-Mutex/spin-timeout.jpg"></p>
<p>如果此时G0完成了工作，调用Unlock，此时如果等待队列中不存在等待的goroutines，或者说已经有一个goroutines已经被唤醒，或者已经有goroutines获取到锁的话，就不会去唤醒任何goroutines。</p>
<ul>
<li><p>此时G0会从唤醒等待队列队首的goroutines,如下图，如果g1还处于自旋状态的话，此时mutexWoken位是置1的，所以G0此时不会唤醒任何的队列中的goroutines.</p>
</li>
<li><p>如果此时g1退出自旋状态，将mutexWoken置0，那么此时G0会从唤醒等待队列队首的goroutines,g3会加入到p0.runnext,如下图，最终获取到锁，如果在调度过程中有其他新的goroutines进去，可能提前获取到锁的话，g3会加入到队列的队首，等待下次唤醒。</p>
</li>
</ul>
<p><img src="/2022/07/12/golang-sync-Mutex/normal-unlock.jpg"></p>
<h3 id="饥饿模式"><a href="#饥饿模式" class="headerlink" title="饥饿模式"></a>饥饿模式</h3><p>首先我们通过下图来看下饥饿模式的流程。</p>
<p>当前G0当前持有锁，当前有3个goroutines在等待锁，分别是g3,g4,g5都等待队列中，按照FIFO原则。</p>
<p>如果此时G1新进来去获取锁，G1在饥饿模式下不会进入自旋，会按照FIFO的原则直接将goroutines放到队列中等待。</p>
<p><img src="/2022/07/12/golang-sync-Mutex/starving-lock.jpg"></p>
<p>此时G0完成了工作，调用Unlock，此时G0会从唤醒等待队列队首的goroutines,如下图，会将g3唤醒，放到p的runnext上，P0下一次调度执行该goroutines,与正常模式不同的是，此时G0会调用goyeild,会让出时间片，将自己放入到P0本地runq的队尾，等待下次调度，那么由于G3在p0 nextq上，g3就会马上获得时间片，获取到锁。</p>
<p><img src="/2022/07/12/golang-sync-Mutex/starving-unlock.jpg"></p>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> lockSlow() &#123;</span><br><span class="line">	<span class="keyword">var</span> waitStartTime <span class="type">int64</span></span><br><span class="line">	starving := <span class="literal">false</span></span><br><span class="line">	awoke := <span class="literal">false</span></span><br><span class="line">	iter := <span class="number">0</span></span><br><span class="line">	old := m.state</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// Don&#x27;t spin in starvation mode, ownership is handed off to waiters</span></span><br><span class="line">		<span class="comment">// so we won&#x27;t be able to acquire the mutex anyway.</span></span><br><span class="line">        <span class="comment">// //判断是否有锁并且不处于饥饿模式，并且runtime满足自旋的要求,满足自旋的要求的话，进去自旋状态。直到获取到锁，或者不满足自旋的转态。</span></span><br><span class="line">        <span class="comment">// old&amp;(mutexLocked|mutexStarving) == mutexLocked 表示是否处于锁定并且非饥饿状态</span></span><br><span class="line">        <span class="comment">// runtime_canSpin返回的是runtime是否能自旋，条件如上介绍的</span></span><br><span class="line">		<span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) &#123;</span><br><span class="line">			<span class="comment">// Active spinning makes sense.</span></span><br><span class="line">			<span class="comment">// Try to set mutexWoken flag to inform Unlock</span></span><br><span class="line">			<span class="comment">// to not wake other blocked goroutines.</span></span><br><span class="line">            <span class="comment">// old&amp;mutexWoken == 0标明在正常模式下没有其他正在唤醒的goroutines</span></span><br><span class="line">            <span class="comment">// old&gt;&gt;mutexWaiterShift != 0 标明等待队列中有其他的goroutines在等待锁。</span></span><br><span class="line">            <span class="comment">// 这里将state mutexWoken置为1,是为了防止再Unlock的时候去唤醒其他的阻塞的协程。</span></span><br><span class="line">			<span class="keyword">if</span> !awoke &amp;&amp; old&amp;mutexWoken == <span class="number">0</span> &amp;&amp; old&gt;&gt;mutexWaiterShift != <span class="number">0</span> &amp;&amp;</span><br><span class="line">				atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) &#123;</span><br><span class="line">				awoke = <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">			runtime_doSpin()</span><br><span class="line">			iter++</span><br><span class="line">			old = m.state</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 计算当前互斥锁的状态</span></span><br><span class="line">		<span class="built_in">new</span> := old</span><br><span class="line">		<span class="comment">// Don&#x27;t try to acquire starving mutex, new arriving goroutines must queue.</span></span><br><span class="line">        <span class="comment">// 如果老的状态处于非饥饿状态的话，给new加锁</span></span><br><span class="line">        <span class="comment">// 如果处于饥饿状态的话，新到来的goroutines需要排队。</span></span><br><span class="line">		<span class="keyword">if</span> old&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="built_in">new</span> |= mutexLocked</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 如果老的状态处于锁定或者饥饿模式下，则将等待者数量+1</span></span><br><span class="line">		<span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">			<span class="built_in">new</span> += <span class="number">1</span> &lt;&lt; mutexWaiterShift</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// The current goroutine switches mutex to starvation mode.</span></span><br><span class="line">		<span class="comment">// But if the mutex is currently unlocked, don&#x27;t do the switch.</span></span><br><span class="line">		<span class="comment">// Unlock expects that starving mutex has waiters, which will not</span></span><br><span class="line">		<span class="comment">// be true in this case.</span></span><br><span class="line">        <span class="comment">// 如果老的状态在锁定状态，并且当前处于饥饿模式的话，则要切换状态到饥饿模式。</span></span><br><span class="line">        <span class="comment">// 如果当前处于未锁定的状态的话，</span></span><br><span class="line">		<span class="keyword">if</span> starving &amp;&amp; old&amp;mutexLocked != <span class="number">0</span> &#123;</span><br><span class="line">			<span class="built_in">new</span> |= mutexStarving</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 需要将mutexWoken置为0，这样使得unlock的时候可以去唤醒goroutines</span></span><br><span class="line">		<span class="keyword">if</span> awoke &#123;</span><br><span class="line">			<span class="comment">// The goroutine has been woken from sleep,</span></span><br><span class="line">			<span class="comment">// so we need to reset the flag in either case.</span></span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexWoken == <span class="number">0</span> &#123;</span><br><span class="line">				throw(<span class="string">&quot;sync: inconsistent mutex state&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">new</span> &amp;^= mutexWoken</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果老的状态是未加锁，并且不处于饥饿状态，获取到锁直接退出。</span></span><br><span class="line">			<span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">break</span> <span class="comment">// locked the mutex with CAS</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// If we were already waiting before, queue at the front of the queue.</span></span><br><span class="line">            <span class="comment">// 如果这里的waitStartTime不为0的话，标明这个goroutines已经等待过了，需要放到队列头。</span></span><br><span class="line">			queueLifo := waitStartTime != <span class="number">0</span></span><br><span class="line">			<span class="keyword">if</span> waitStartTime == <span class="number">0</span> &#123;</span><br><span class="line">				waitStartTime = runtime_nanotime()</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">// 阻塞等待，如果等待过的goroutines加到队头，新的goroutines的话加入到队尾等待。</span></span><br><span class="line">            <span class="comment">// runtime_SemacquireMutex这个会在方法中不断调用尝试获取锁并休眠当前 Goroutine 等待信号量的释放，一旦当前 Goroutine 可以获取信号量，它就会立刻返回</span></span><br><span class="line">			runtime_SemacquireMutex这个会(&amp;m.sema, queueLifo, <span class="number">1</span>)</span><br><span class="line">            <span class="comment">// 当前goroutines已经饥饿了状态不变化，如果等待的时间超过了1ms的话，切换成饥饿状态。</span></span><br><span class="line">			starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs</span><br><span class="line">			old = m.state</span><br><span class="line">            <span class="comment">// 如果当前处于饥饿状态的话，就说明当前的goroutines是被唤醒的，锁是处于释放状态。</span></span><br><span class="line">			<span class="keyword">if</span> old&amp;mutexStarving != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">// If this goroutine was woken and mutex is in starvation mode,</span></span><br><span class="line">				<span class="comment">// ownership was handed off to us but mutex is in somewhat</span></span><br><span class="line">				<span class="comment">// inconsistent state: mutexLocked is not set and we are still</span></span><br><span class="line">				<span class="comment">// accounted as waiter. Fix that.</span></span><br><span class="line">				<span class="keyword">if</span> old&amp;(mutexLocked|mutexWoken) != <span class="number">0</span> || old&gt;&gt;mutexWaiterShift == <span class="number">0</span> &#123;</span><br><span class="line">					throw(<span class="string">&quot;sync: inconsistent mutex state&quot;</span>)</span><br><span class="line">				&#125;</span><br><span class="line">                <span class="comment">// 将等待的goroutines - 1</span></span><br><span class="line">				delta := <span class="type">int32</span>(mutexLocked - <span class="number">1</span>&lt;&lt;mutexWaiterShift)</span><br><span class="line">                <span class="comment">// 如果当前不处于饥饿模式，或者只剩下一个goroutines在等待了，也退出饥饿模式。</span></span><br><span class="line">				<span class="keyword">if</span> !starving || old&gt;&gt;mutexWaiterShift == <span class="number">1</span> &#123;</span><br><span class="line">					<span class="comment">// Exit starvation mode.</span></span><br><span class="line">					<span class="comment">// Critical to do it here and consider wait time.</span></span><br><span class="line">					<span class="comment">// Starvation mode is so inefficient, that two goroutines</span></span><br><span class="line">					<span class="comment">// can go lock-step infinitely once they switch mutex</span></span><br><span class="line">					<span class="comment">// to starvation mode.</span></span><br><span class="line">					delta -= mutexStarving</span><br><span class="line">				&#125;</span><br><span class="line">				atomic.AddInt32(&amp;m.state, delta)</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			awoke = <span class="literal">true</span></span><br><span class="line">			iter = <span class="number">0</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			old = m.state</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		race.Acquire(unsafe.Pointer(m))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Unlock unlocks m.</span></span><br><span class="line"><span class="comment">// It is a run-time error if m is not locked on entry to Unlock.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A locked Mutex is not associated with a particular goroutine.</span></span><br><span class="line"><span class="comment">// It is allowed for one goroutine to lock a Mutex and then</span></span><br><span class="line"><span class="comment">// arrange for another goroutine to unlock it.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Unlock() &#123;</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		_ = m.state</span><br><span class="line">		race.Release(unsafe.Pointer(m))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Fast path: drop lock bit.</span></span><br><span class="line">	<span class="built_in">new</span> := atomic.AddInt32(&amp;m.state, -mutexLocked)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">new</span> != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// Outlined slow path to allow inlining the fast path.</span></span><br><span class="line">		<span class="comment">// To hide unlockSlow during tracing we skip one extra frame when tracing GoUnblock.</span></span><br><span class="line">		m.unlockSlow(<span class="built_in">new</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> unlockSlow(<span class="built_in">new</span> <span class="type">int32</span>) &#123;</span><br><span class="line">    <span class="comment">// unlock一个为加锁的Mutex,panic</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">new</span>+mutexLocked)&amp;mutexLocked == <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">&quot;sync: unlock of unlocked mutex&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line">		old := <span class="built_in">new</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="comment">// If there are no waiters or a goroutine has already</span></span><br><span class="line">			<span class="comment">// been woken or grabbed the lock, no need to wake anyone.</span></span><br><span class="line">			<span class="comment">// In starvation mode ownership is directly handed off from unlocking</span></span><br><span class="line">			<span class="comment">// goroutine to the next waiter. We are not part of this chain,</span></span><br><span class="line">			<span class="comment">// since we did not observe mutexStarving when we unlocked the mutex above.</span></span><br><span class="line">			<span class="comment">// So get off the way.</span></span><br><span class="line">            <span class="comment">// old&gt;&gt;mutexWaiterShift == 0 判断锁上是否还有等待的goroutine</span></span><br><span class="line">            <span class="comment">// old&amp;(mutexLocked|mutexWoken|mutexStarving) 表示说已经有goroutines获取锁，或者说被唤醒,或者切换到饥饿模式了，这样直接返回，不需要唤醒任何goroutines</span></span><br><span class="line">            <span class="comment">// 因为饥饿模式下我们将锁直接交给下一个goroutines，不在这个分支里。</span></span><br><span class="line">			<span class="keyword">if</span> old&gt;&gt;mutexWaiterShift == <span class="number">0</span> || old&amp;(mutexLocked|mutexWoken|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Grab the right to wake someone.</span></span><br><span class="line">			<span class="built_in">new</span> = (old - <span class="number">1</span>&lt;&lt;mutexWaiterShift) | mutexWoken</span><br><span class="line">			<span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">				runtime_Semrelease(&amp;m.sema, <span class="literal">false</span>, <span class="number">1</span>)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			old = m.state</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Starving mode: handoff mutex ownership to the next waiter, and yield</span></span><br><span class="line">		<span class="comment">// our time slice so that the next waiter can start to run immediately.</span></span><br><span class="line">		<span class="comment">// Note: mutexLocked is not set, the waiter will set it after wakeup.</span></span><br><span class="line">		<span class="comment">// But mutex is still considered locked if mutexStarving is set,</span></span><br><span class="line">		<span class="comment">// so new coming goroutines won&#x27;t acquire it.</span></span><br><span class="line">        <span class="comment">// handoff的做法是release函数将waiter加到当前P的runnext中，然后通过调用goyeild立即让出时间片，所以next waiter能马上运行，获取到锁。goyield 类似于 Gosched，但它会发出一个“抢占式”跟踪事件，更重要的是，将当前 G 放在本地 runq 而不是全局 runq 上。我们只在饥饿状态下（handoff=true）这样做，因为在非饥饿情况下，新的goroutines可能会在我们让出调度时获取信号量，这将是浪费的。相反，我们等待进入饥饿状态，然后开始直接切换票和 P。</span></span><br><span class="line">		runtime_Semrelease(&amp;m.sema, <span class="literal">true</span>, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>sync-rwmutex</title>
    <url>/2022/07/19/sync-rwmutex/</url>
    <content><![CDATA[<p>基于golang 1.17版本</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A RWMutex is a reader/writer mutual exclusion lock.</span></span><br><span class="line"><span class="comment">// The lock can be held by an arbitrary number of readers or a single writer.</span></span><br><span class="line"><span class="comment">// The zero value for a RWMutex is an unlocked mutex.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A RWMutex must not be copied after first use.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If a goroutine holds a RWMutex for reading and another goroutine might</span></span><br><span class="line"><span class="comment">// call Lock, no goroutine should expect to be able to acquire a read lock</span></span><br><span class="line"><span class="comment">// until the initial read lock is released. In particular, this prohibits</span></span><br><span class="line"><span class="comment">// recursive read locking. This is to ensure that the lock eventually becomes</span></span><br><span class="line"><span class="comment">// available; a blocked Lock call excludes new readers from acquiring the</span></span><br><span class="line"><span class="comment">// lock.</span></span><br><span class="line"><span class="keyword">type</span> RWMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">	w           Mutex  <span class="comment">// held if there are pending writers</span></span><br><span class="line">	writerSem   <span class="type">uint32</span> <span class="comment">// semaphore for writers to wait for completing readers</span></span><br><span class="line">	readerSem   <span class="type">uint32</span> <span class="comment">// semaphore for readers to wait for completing writers</span></span><br><span class="line">	readerCount <span class="type">int32</span>  <span class="comment">// number of pending readers</span></span><br><span class="line">	readerWait  <span class="type">int32</span>  <span class="comment">// number of departing readers</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读写锁是更细粒度的锁。通过RWMutex的结构体可以知道该锁消耗24字节。</p>
<ul>
<li>w: 复用了互斥锁的能理，用来表示是否有阻塞的writer</li>
<li>writerSem: writers等待readers完成的信号量</li>
<li>readerSem; readers等待writers完成的信号量</li>
<li>readerCount: 已获取了读锁的数量，当writer获取到锁时，该值&lt;0</li>
<li>readerWait: 获取到写锁时，此时已获取的读锁的数量。</li>
</ul>
<h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p>加写锁可以分为2种情况</p>
<ul>
<li>是否有goroutines获取了写锁：如下图左边所示，如果g0已经获取了写锁，那么g1再去获取写锁的话，就呼阻塞在w互斥锁上，等待g1释放互斥锁后，再执行后续操作。</li>
<li>是否有goroutines获取了读锁的话：如下图右边所示，如果g1已经获取了读锁，那么g1再去获取写锁时，由于当前无写锁，g1获取了w互斥锁后，会将利用原子操作将readCount - maxReaders，将readCount置为负数的话，主要是为阻塞后续的加读锁操作，防止写锁饿死。也就说只有有写锁获取了w互斥锁后，尽量阻塞其他的读锁。然后将readerWait值置为当前已获取读锁的goroutines的数量，如果!&#x3D;0的话，则将自己阻塞在writeSem上，等所有读锁释放了锁之后唤醒。</li>
</ul>
<p><img src="/2022/07/19/sync-rwmutex/rwmutex-lock.jpg"></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Lock locks rw for writing.</span></span><br><span class="line"><span class="comment">// If the lock is already locked for reading or writing,</span></span><br><span class="line"><span class="comment">// Lock blocks until the lock is available.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> Lock() &#123;</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		_ = rw.w.state</span><br><span class="line">		race.Disable()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// First, resolve competition with other writers.</span></span><br><span class="line">    <span class="comment">// 阻塞其他的writers,保证只有一个writer</span></span><br><span class="line">	rw.w.Lock()</span><br><span class="line">	<span class="comment">// Announce to readers there is a pending writer.</span></span><br><span class="line">    <span class="comment">// 这里讲readerCount-rwmutexMaxReaders，其实将readerCount置为负数了，标明有一个pending的writer.</span></span><br><span class="line">    <span class="comment">// 这里也就是获取了写锁之后，会阻塞读锁的获取。</span></span><br><span class="line">	r := atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders</span><br><span class="line">	<span class="comment">// Wait for active readers.</span></span><br><span class="line">    <span class="comment">// 这里r是标明当前已经获取到读锁的goroutines的数量，如果这里不为0的话，设置readerWait，说明有未释放的读锁数量，并将自己挂在writeSem信号量上休眠，等待所有读锁释放后，唤醒。</span></span><br><span class="line">	<span class="keyword">if</span> r != <span class="number">0</span> &amp;&amp; atomic.AddInt32(&amp;rw.readerWait, r) != <span class="number">0</span> &#123;</span><br><span class="line">		runtime_SemacquireMutex(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		race.Enable()</span><br><span class="line">		race.Acquire(unsafe.Pointer(&amp;rw.readerSem))</span><br><span class="line">		race.Acquire(unsafe.Pointer(&amp;rw.writerSem))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Unlock"><a href="#Unlock" class="headerlink" title="Unlock"></a>Unlock</h3><h4 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h4><p>写锁的释放流程很简单</p>
<ol>
<li>第一步先讲readerCount+maxReaders，标明没有正在执行的writer了，这样可以不阻塞后续的读锁。</li>
<li>如果在readerSem上有因为写操作阻塞的读操作的话，唤醒这个信号量上的所有的goroutines.</li>
<li>最后释放互斥锁， 这样下一个写操作可以获取到该互斥锁。这里先唤醒reader再释放写锁，可以保证读操作不会被连续的写操作饿死。</li>
</ol>
<p><img src="/2022/07/19/sync-rwmutex/rwmutex-unlock.jpg"></p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Unlock unlocks rw for writing. It is a run-time error if rw is</span></span><br><span class="line"><span class="comment">// not locked for writing on entry to Unlock.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// As with Mutexes, a locked RWMutex is not associated with a particular</span></span><br><span class="line"><span class="comment">// goroutine. One goroutine may RLock (Lock) a RWMutex and then</span></span><br><span class="line"><span class="comment">// arrange for another goroutine to RUnlock (Unlock) it.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> Unlock() &#123;</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		_ = rw.w.state</span><br><span class="line">		race.Release(unsafe.Pointer(&amp;rw.readerSem))</span><br><span class="line">		race.Disable()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Announce to readers there is no active writer.</span></span><br><span class="line">    <span class="comment">// 把readerCount + rwmutexMaxReaders，将readerCount变为整数，标明没有正在执行的writer了。</span></span><br><span class="line">	r := atomic.AddInt32(&amp;rw.readerCount, rwmutexMaxReaders)</span><br><span class="line">    <span class="comment">// 如果Unlocok一个没有Lock的RwMutex会panic</span></span><br><span class="line">	<span class="keyword">if</span> r &gt;= rwmutexMaxReaders &#123;</span><br><span class="line">		race.Enable()</span><br><span class="line">		throw(<span class="string">&quot;sync: Unlock of unlocked RWMutex&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Unblock blocked readers, if any.</span></span><br><span class="line">    <span class="comment">// 如果存在因为writer阻塞的reader的话，将所有尝试获取读锁的goroutine唤醒</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="type">int</span>(r); i++ &#123;</span><br><span class="line">		runtime_Semrelease(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Allow other writers to proceed.</span></span><br><span class="line">    <span class="comment">// 释放写锁，这样下一个写锁可以尝试获取。</span></span><br><span class="line">    <span class="comment">// 这里先唤醒reader再释放写锁，可以保证读操作不会被连续的写操作饿死。</span></span><br><span class="line">	rw.w.Unlock()</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		race.Enable()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RLock"><a href="#RLock" class="headerlink" title="RLock"></a>RLock</h3><h4 id="流程-2"><a href="#流程-2" class="headerlink" title="流程"></a>流程</h4><ul>
<li>获取读锁的流程比较简单，如果在没有获取写锁的goroutines，仅仅将readerCount +1</li>
<li>如果有goroutines已经获取了写锁的话也就是readerCount  &lt;0,此时将自己阻塞在readerSem信号量上，等写锁释放后将goroutines唤醒。</li>
</ul>
<p><img src="/2022/07/19/sync-rwmutex/rwmutex-rlock.jpg"></p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RLock locks rw for reading.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// It should not be used for recursive read locking; a blocked Lock</span></span><br><span class="line"><span class="comment">// call excludes new readers from acquiring the lock. See the</span></span><br><span class="line"><span class="comment">// documentation on the RWMutex type.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RLock() &#123;</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		_ = rw.w.state</span><br><span class="line">		race.Disable()</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 如果readerCount &lt;0 ，说明有goroutines应获取了写锁，所以此时将goroutines挂到readerSem信号量上，休眠，待写锁释放后，唤醒。</span></span><br><span class="line">	<span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerCount, <span class="number">1</span>) &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// A writer is pending, wait for it.</span></span><br><span class="line">		runtime_SemacquireMutex(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		race.Enable()</span><br><span class="line">		race.Acquire(unsafe.Pointer(&amp;rw.readerSem))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RUnlock"><a href="#RUnlock" class="headerlink" title="RUnlock"></a>RUnlock</h3><h4 id="流程-3"><a href="#流程-3" class="headerlink" title="流程"></a>流程</h4><ul>
<li>如果没有任何写锁相关的操作的话，Runlock只是将readerCount-1.</li>
<li>如果此时readerCount &lt;0，标明当前有goroutines已经获取了互斥锁，等待所有读操作释放锁后，获取写锁。将readerWait -1， 标明的是当前还有多少个goroutines持有读锁，如果此时readerWait &#x3D;&#x3D; 0，说明所有的读锁已经释放，则将writerSem上阻塞的goroutine唤醒。</li>
</ul>
<p><img src="/2022/07/19/sync-rwmutex/rwmutex-runlock.jpg"></p>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RUnlock undoes a single RLock call;</span></span><br><span class="line"><span class="comment">// it does not affect other simultaneous readers.</span></span><br><span class="line"><span class="comment">// It is a run-time error if rw is not locked for reading</span></span><br><span class="line"><span class="comment">// on entry to RUnlock.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RUnlock() &#123;</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		_ = rw.w.state</span><br><span class="line">		race.ReleaseMerge(unsafe.Pointer(&amp;rw.writerSem))</span><br><span class="line">		race.Disable()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> r := atomic.AddInt32(&amp;rw.readerCount, <span class="number">-1</span>); r &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 如果r&lt;0的话说明有一个获取了写锁但在等待读锁全部释放的writer.</span></span><br><span class="line">		<span class="comment">// Outlined slow-path to allow the fast-path to be inlined</span></span><br><span class="line">		rw.rUnlockSlow(r)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		race.Enable()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> rUnlockSlow(r <span class="type">int32</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> r+<span class="number">1</span> == <span class="number">0</span> || r+<span class="number">1</span> == -rwmutexMaxReaders &#123;</span><br><span class="line">		race.Enable()</span><br><span class="line">		throw(<span class="string">&quot;sync: RUnlock of unlocked RWMutex&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// A writer is pending.</span></span><br><span class="line">    <span class="comment">// 每次都减少readerWait的数量，等到readerWait ==0的时候表明所有的获取读锁的goroutines都释放了锁，此时可以讲writer唤醒，执行写操作。</span></span><br><span class="line">	<span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerWait, <span class="number">-1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// The last reader unblocks the writer.</span></span><br><span class="line">		runtime_Semrelease(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>google-autopilot-workload</title>
    <url>/2022/08/10/google-autopilot-workload/</url>
    <content><![CDATA[<h2 id="Autopliot-workload-autoscaling-at-google"><a href="#Autopliot-workload-autoscaling-at-google" class="headerlink" title="Autopliot: workload autoscaling at google"></a>Autopliot: workload autoscaling at google</h2><p>最近在看google的这篇论文<code>Autopilot: workload autoscaling at Google</code>，文章是2020年在EuroSys上发布的，google公司内部在borg系统上做的关于VPA和HPA的一些尝试。</p>
<h3 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h3><p><img src="/./2022/08/10/google-autopilot-workload/autopilot.jpg" alt="autopilot"></p>
<p>autopilot系统主要是使用纵向扩容动态调整workload的CPU和Memory，这样减少应用申请资源量与实际使用量之间的gap,但是又能保证应用有足够的资源，尽量减少应用遇到OOM或者因为CPU抢占导致的性能衰减。使用横向扩容调整实例个数。</p>
<p>autopilot系统主要有3个控制系统，1个是做workload级别的HPA，剩余2个是做pod级别的VPA（一个是CPU一个是Memory）,当前还不支持跨workload的调整。主要由以下几个组件组成：</p>
<ul>
<li>Recommender: 主要是根据历史的资源使用情况以及选择的算法计算出work的实例个数或者是应用的limit，当前有3个实例。</li>
<li>Autopilot Service: 主备，主要是给某个job选定一个recommender,讲recommender计算的出来的recommendation通过一个Actuator job下发给borg master,如果是修改workload数量的话，borg master会创建和删除实例，如果是修改资源限制的话，borg master会先查看当前节点资源是否能满足，不能满足的话可能需要通过抢占在节点上释放资源，然后再联系这个节点的borglet去做应用变化。</li>
<li>Resource usage log: 单独的监控系统监控每个task的资源使用量， recommender从中获取需要的资源使用量信息，数据的预处理都是由这个monitoring系统处理，这样可以减少recommender的资源消耗，不需要存储监控历史数据。</li>
</ul>
<h3 id="Vertical-per-task-autoscaling"><a href="#Vertical-per-task-autoscaling" class="headerlink" title="Vertical(per task) autoscaling"></a>Vertical(per task) autoscaling</h3><p>autopilot service会根据以下一些情况选择recommender</p>
<ul>
<li>根据期望调整的是CPU还是memory资源</li>
<li>job对out of service的忍受程度（能否忍受时延变大，或者OOM敏感等）</li>
<li>或者用户自定义输入，比如指定recommender，或者一些附加的参数限制autopilot的行为，比如limit的上下限等。</li>
</ul>
<h4 id="Preprocessing"><a href="#Preprocessing" class="headerlink" title="Preprocessing"></a>Preprocessing</h4><p>监控系统采集每个task的一些基础监控指标，比如cpu,memory,或者查询数量等，𝑟𝑖 [𝜏]表示的是task i在时间𝜏的值，采样时间点为每秒一个点。</p>
<p>为了减少数据存储的数量，data monitoring预处理这些数据，对数据进行聚合，通常来说大概是5min吧。更通用的说，对于每个窗口s𝑖 [t]是一个向量, 基于原始的监控数据𝑟𝑖 [𝜏] 𝜏 ∈ 𝑡做一个统计分析。</p>
<ul>
<li>CPU:对于CPU资源来说，可能按照利用率分为400个桶，s𝑖 [t][k]表示的是落入到第k个桶的数据个数。s𝑖 [t][𝑘] &#x3D;|{𝑟𝑖 [𝜏] : 𝜏 ∈ 𝑡 ∧𝑏[𝑘 − 1] ≤ 𝑟𝑖 [𝜏] &lt; 𝑏 [𝑘]}|, 𝑏 [𝑘]代表的是第k个桶的边界值，这个值是固定的提前在监控系统里已设置好的值。</li>
<li>Memory:对于内存资源来说，只记录在窗口周期内的最大值，所以s𝑖 [t][k]中只有1个值非0，内存资源之所以使用峰值，是因为task对内存不足更敏感（内存是不可压缩资源，内存不足会触发OOM，CPU限流的话会只是影响时延）</li>
</ul>
<p>𝑠 [𝑡 ]是聚合所有task，𝑠 [𝑡 ] [𝑘] &#x3D;Σ𝑖𝑠𝑖 [𝑡 ] [𝑘],没必要单独区分是哪个task，在borg系统里，jobs里task基本上可以可互换的实例，应该给每个实例设置相同的limit</p>
<h4 id="Moving-window-recommenders"><a href="#Moving-window-recommenders" class="headerlink" title="Moving window recommenders"></a>Moving window recommenders</h4><p>我们期望limit迅速增加以应对使用率上升，但在系统负载压力变小后希望limit慢慢减少，以避免对暂时向下波动反应过快。为了平滑对负载峰值的响应，算法里引入了加权权重指数衰减的信号𝑤[𝜏]&#x3D; <img src="/./2022/08/10/google-autopilot-workload/w.png" alt="img"></p>
<p>可能不同的资源衰减周期设置的不一致，对于CPU资源来说，衰减周期设置为12小时，对于内存资源来说衰减周期设置为48小时，每过一个衰减周期，权限减半。</p>
<p>推荐值S[t]有多种计算方式：</p>
<ul>
<li><p>𝑆max [𝑡] &#x3D; max𝜏 ∈[𝑡−(𝑁-1),…,t]{𝑏 [ 𝑗 ]: s𝑖 [𝜏][j]&gt;0} ,取最近的N个样本中，非空桶中的最大值，N是一个固定值。</p>
</li>
<li><p>weighted average:</p>
<p><img src="/./2022/08/10/google-autopilot-workload/time-weighted.PNG" alt="time-weighted"></p>
<p>其中<img src="/./2022/08/10/google-autopilot-workload/avg.PNG" alt="avg">算的是这个时间窗口的平均值，然后再乘以衰减权重，最后算一个平均值。</p>
</li>
<li><p>𝑗-%ile of adjusted usage (𝑆𝑝𝑗)：</p>
</li>
</ul>
<p><img src="/./2022/08/10/google-autopilot-workload/h.PNG" alt="h"></p>
<p>这个算法里先拿bucket里的数量乘以衰减系数，然后再乘以桶的边界值，然后最后返回的是该统计值的百分位值。</p>
<p>autopilot可能利用不同的计算方式对于不同的资源以及job类型。</p>
<p>对于CPU资源来说</p>
<ul>
<li>batch job: 使用Savg,这里假设前提是batch job能忍受CPU限流，所以这里认为最有效的limit设置方式就是job的平均的load的使用率。</li>
<li>serving jobs: 𝑆𝑝95或者𝑆𝑝90，基于job的时延敏感程度来设置</li>
</ul>
<p>对于内存来说，要根据job对OOM的忍受程度来采用不同的计算方法。默认我们任务对于大部分的应用来说OOM忍受程度都为低，用户可以自己设置自己的忍受程度。</p>
<ul>
<li>𝑆𝑝98对于大多数Low OOM tolerence</li>
<li>Smax对于Minimal OOM tolerence</li>
<li>对于能忍受的Job来说，取Sp60和0.5Smax的最大值</li>
</ul>
<p>最后根据计算出来的recommendation，会往上浮10~15%的安全边际，最后我们取最近一个小时内看到的最大值来减少波动。</p>
<h4 id="Recommenders-based-on-machine-learning"><a href="#Recommenders-based-on-machine-learning" class="headerlink" title="Recommenders based on machine learning"></a>Recommenders based on machine learning</h4><p>Autopilot ML recommender首先指定了成本函数，对于每个job来说，自动调整参数最终使得成本函数得到最优，主要时调整的是之前算法中一些根据经验值设置的参数，比如缩减率,安全边际,缩容的平滑窗口等。</p>
<p>ML recommender由大量的模型组成。对于每个job来说周期性选择表现最优的模型（根据成本函数以及一些历史数据计算得出）,对于ML来说，其结果的可解释性往往被人挑战，但是对autopolit来说，设置的limit必须对job onwer解释，为什么设置成这个值。</p>
<h3 id="Horizontal-autoscaling"><a href="#Horizontal-autoscaling" class="headerlink" title="Horizontal autoscaling"></a>Horizontal autoscaling</h3><ul>
<li>CPU 利用率：HPA计算目标值需要以下参数<ul>
<li>job owner指定cpu usage的平均窗口（默认是5min）</li>
<li>a horizon length 𝑇默认是72h</li>
<li>statistics 𝑆: max or 𝑃95, the 95%ile;</li>
<li>the target average utilization 𝑟 ∗</li>
</ul>
</li>
</ul>
<p>当前的计算方法是取最近的T时间窗 <img src="/./2022/08/10/google-autopilot-workload/hpa.PNG" alt="hpa"></p>
<p>把每个取样点所有task的cpu使用率相加，根据选择的静态函数是max还是P95计算出一个历史使用率值，然后除以目标平均使用率得到一个推荐值</p>
<ul>
<li>Target Size: job owner指定一个function来计算，function利用从监控系统获取的数据，例如job利用查询系统管理请求，可以根据P95请求处理时间来做HPA指标。文件系统可能利用管理的文件空间大小</li>
</ul>
<p>最后得到一系列𝑛𝑟[𝑡]最后按照一个稳定的窗口防止实例数的突变，autopilot提供了以下几种平滑策略：</p>
<ul>
<li><p>deferred downscaling（延迟缩减）：返回最近Td周期内的推荐值最大值，这样可以延迟缩容，但是扩容是马上执行的。对于google内部来说40%左右Td设置为2天，35%设置成3天。</p>
</li>
<li><p>slow decay（缓慢衰减）：避免同时终止过多的task，如果当前的实例数量大于𝑛𝑠[𝑡],每5min就会终止一些task，具体的终止的数量，可能设置成一个周期的一半，98%的job设置成1h内的一半。</p>
</li>
<li><p>defer small changes：在某种程度上，与缓慢衰减相反，当前实例数与推荐值相差较小时，则忽略。类似kubernetes内的tolerence</p>
</li>
<li><p>limiting growth: 允许job ownner限制正在一部分初始化的任务，因此限制扩容的速率。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes，autoscaling</tag>
      </tags>
  </entry>
  <entry>
    <title>sync-waitgroup</title>
    <url>/2022/07/19/sync-waitgroup/</url>
    <content><![CDATA[<p>基于golang 1.17版本</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A WaitGroup waits for a collection of goroutines to finish.</span></span><br><span class="line"><span class="comment">// The main goroutine calls Add to set the number of</span></span><br><span class="line"><span class="comment">// goroutines to wait for. Then each of the goroutines</span></span><br><span class="line"><span class="comment">// runs and calls Done when finished. At the same time,</span></span><br><span class="line"><span class="comment">// Wait can be used to block until all goroutines have finished.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A WaitGroup must not be copied after first use.</span></span><br><span class="line"><span class="keyword">type</span> WaitGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">	noCopy noCopy</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 64-bit value: high 32 bits are counter, low 32 bits are waiter count.</span></span><br><span class="line">	<span class="comment">// 64-bit atomic operations require 64-bit alignment, but 32-bit</span></span><br><span class="line">	<span class="comment">// compilers do not ensure it. So we allocate 12 bytes and then use</span></span><br><span class="line">	<span class="comment">// the aligned 8 bytes in them as state, and the other 4 as storage</span></span><br><span class="line">	<span class="comment">// for the sema.</span></span><br><span class="line">	state1 [<span class="number">3</span>]<span class="type">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WaitGroup 占用12字节</p>
<ul>
<li>noCopy:  Go中没有原生的禁止拷贝的方式，noCopy是个特殊结构，可以结合govet在分析器会在编译期间检查被拷贝的变量中是否包含noCopy或者是否实现Lock&#x2F;Unlock方法，报错。这样保证只能指针传递保证全局唯一的话。主要是由于锁机制期望成对出现，如果进行拷贝可能导致死锁。</li>
<li>由于原子操作要求64位对齐，所以在32bit系统和64bit系统里state1的结构可能不同,32位系统不能保证64位对齐。通过state函数屏蔽差异。<ul>
<li>64位系统中，高32位为counter，低32位为等待goroutines的数量，剩下为信号量。</li>
<li>低32位为信号量，剩余8个字节自动对齐</li>
</ul>
</li>
</ul>
<p><img src="/./2022/07/19/sync-waitgroup/waitgroup-state.jpg"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// state returns pointers to the state and sema fields stored within wg.state1.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> state() (statep *<span class="type">uint64</span>, semap *<span class="type">uint32</span>) &#123;</span><br><span class="line">     <span class="comment">// 如果地址是64bit对齐的，数组前两个元素做state，后一个元素做信号量</span></span><br><span class="line">     <span class="comment">// 否则数组第一个元素做信号量，后两个元素做state</span></span><br><span class="line">	<span class="keyword">if</span> <span class="type">uintptr</span>(unsafe.Pointer(&amp;wg.state1))%<span class="number">8</span> == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> (*<span class="type">uint64</span>)(unsafe.Pointer(&amp;wg.state1)), &amp;wg.state1[<span class="number">2</span>]</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> (*<span class="type">uint64</span>)(unsafe.Pointer(&amp;wg.state1[<span class="number">1</span>])), &amp;wg.state1[<span class="number">0</span>]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Add adds delta, which may be negative, to the WaitGroup counter.</span></span><br><span class="line"><span class="comment">// If the counter becomes zero, all goroutines blocked on Wait are released.</span></span><br><span class="line"><span class="comment">// If the counter goes negative, Add panics.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Note that calls with a positive delta that occur when the counter is zero</span></span><br><span class="line"><span class="comment">// must happen before a Wait. Calls with a negative delta, or calls with a</span></span><br><span class="line"><span class="comment">// positive delta that start when the counter is greater than zero, may happen</span></span><br><span class="line"><span class="comment">// at any time.</span></span><br><span class="line"><span class="comment">// Typically this means the calls to Add should execute before the statement</span></span><br><span class="line"><span class="comment">// creating the goroutine or other event to be waited for.</span></span><br><span class="line"><span class="comment">// If a WaitGroup is reused to wait for several independent sets of events,</span></span><br><span class="line"><span class="comment">// new Add calls must happen after all previous Wait calls have returned.</span></span><br><span class="line"><span class="comment">// See the WaitGroup example.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> Add(delta <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取state和seme的地址。</span></span><br><span class="line">	statep, semap := wg.state()</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		_ = *statep <span class="comment">// trigger nil deref early</span></span><br><span class="line">		<span class="keyword">if</span> delta &lt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// Synchronize decrements with Wait.</span></span><br><span class="line">			race.ReleaseMerge(unsafe.Pointer(wg))</span><br><span class="line">		&#125;</span><br><span class="line">		race.Disable()</span><br><span class="line">		<span class="keyword">defer</span> race.Enable()</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 将delta增加到计算位。</span></span><br><span class="line">	state := atomic.AddUint64(statep, <span class="type">uint64</span>(delta)&lt;&lt;<span class="number">32</span>)</span><br><span class="line">    <span class="comment">// 获取state高32位，也就是counter的数量</span></span><br><span class="line">	v := <span class="type">int32</span>(state &gt;&gt; <span class="number">32</span>)</span><br><span class="line">    <span class="comment">// 获取state低32位，也就是waiter的数量</span></span><br><span class="line">	w := <span class="type">uint32</span>(state)</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &amp;&amp; delta &gt; <span class="number">0</span> &amp;&amp; v == <span class="type">int32</span>(delta) &#123;</span><br><span class="line">		<span class="comment">// The first increment must be synchronized with Wait.</span></span><br><span class="line">		<span class="comment">// Need to model this as a read, because there can be</span></span><br><span class="line">		<span class="comment">// several concurrent wg.counter transitions from 0.</span></span><br><span class="line">		race.Read(unsafe.Pointer(semap))</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 如果counter数量&lt;0，则程序会panic</span></span><br><span class="line">	<span class="keyword">if</span> v &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;sync: negative WaitGroup counter&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 如果waiter的数量不为0，如果这时增加delta数量，同时v == delta数量</span></span><br><span class="line">    <span class="comment">// 这个时候说明Add和Wait并发调用了，期望在调用Add请求之后再调用Wait.</span></span><br><span class="line">	<span class="keyword">if</span> w != <span class="number">0</span> &amp;&amp; delta &gt; <span class="number">0</span> &amp;&amp; v == <span class="type">int32</span>(delta) &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;sync: WaitGroup misuse: Add called concurrently with Wait&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 如果counter &gt;0，或者没有阻塞的waiter的话直接返回。</span></span><br><span class="line">	<span class="keyword">if</span> v &gt; <span class="number">0</span> || w == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// This goroutine has set counter to 0 when waiters &gt; 0.</span></span><br><span class="line">	<span class="comment">// Now there can&#x27;t be concurrent mutations of state:</span></span><br><span class="line">	<span class="comment">// - Adds must not happen concurrently with Wait,</span></span><br><span class="line">	<span class="comment">// - Wait does not increment waiters if it sees counter == 0.</span></span><br><span class="line">	<span class="comment">// Still do a cheap sanity check to detect WaitGroup misuse.</span></span><br><span class="line">    <span class="comment">// 当goroutines运行到这里的时候，counter数量被设置为0，同时阻塞的waiter&gt;0.我们认为此时不能并发的对state进行修改. Add和Wait不能并发调用。当counter == 0的时候，Wait不能增加waiter的数量。</span></span><br><span class="line">	<span class="keyword">if</span> *statep != state &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;sync: WaitGroup misuse: Add called concurrently with Wait&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Reset waiters count to 0.</span></span><br><span class="line">    <span class="comment">// 这个时候将状态位置0。然后唤醒所有等待的goroutines</span></span><br><span class="line">	*statep = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> ; w != <span class="number">0</span>; w-- &#123;</span><br><span class="line">		runtime_Semrelease(semap, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Wait blocks until the WaitGroup counter is zero.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> Wait() &#123;</span><br><span class="line">    <span class="comment">// 获取state和seme的地址。</span></span><br><span class="line">	statep, semap := wg.state()</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		_ = *statep <span class="comment">// trigger nil deref early</span></span><br><span class="line">		race.Disable()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		state := atomic.LoadUint64(statep)</span><br><span class="line">        <span class="comment">// 获取state高32位，也就是counter的数量</span></span><br><span class="line">		v := <span class="type">int32</span>(state &gt;&gt; <span class="number">32</span>)</span><br><span class="line">        <span class="comment">// 获取state低32位，也就是waiter的数量</span></span><br><span class="line">		w := <span class="type">uint32</span>(state)</span><br><span class="line">        <span class="comment">// 当counter == 0的时候，直接返回。</span></span><br><span class="line">		<span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// Counter is 0, no need to wait.</span></span><br><span class="line">			<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">				race.Enable()</span><br><span class="line">				race.Acquire(unsafe.Pointer(wg))</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Increment waiters count.</span></span><br><span class="line">        <span class="comment">// 使用CAS操作增加waiter的数量，如果statep发生变化，则利用外部for循环重试。</span></span><br><span class="line">		<span class="keyword">if</span> atomic.CompareAndSwapUint64(statep, state, state+<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> race.Enabled &amp;&amp; w == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">// Wait must be synchronized with the first Add.</span></span><br><span class="line">				<span class="comment">// Need to model this is as a write to race with the read in Add.</span></span><br><span class="line">				<span class="comment">// As a consequence, can do the write only for the first waiter,</span></span><br><span class="line">				<span class="comment">// otherwise concurrent Waits will race with each other.</span></span><br><span class="line">				race.Write(unsafe.Pointer(semap))</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">// 这里将自己挂起到semap这个信号量上，等待counter==0后被唤醒。</span></span><br><span class="line">			runtime_Semacquire(semap)</span><br><span class="line">            <span class="comment">// Add函数在唤醒goroutines时会将statep置为0，这里为double check</span></span><br><span class="line">			<span class="keyword">if</span> *statep != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="built_in">panic</span>(<span class="string">&quot;sync: WaitGroup is reused before previous Wait has returned&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">				race.Enable()</span><br><span class="line">				race.Acquire(unsafe.Pointer(wg))</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
</search>
